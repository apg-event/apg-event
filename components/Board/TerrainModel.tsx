/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useLayoutEffect, useRef, useMemo } from 'react';
import { useGLTF } from '@react-three/drei';
import { useThree } from '@react-three/fiber';
import * as THREE from 'three';
import { KTX2Loader } from 'three-stdlib';
import { treePositions } from './treeCoordinates';

// --- INSTANCING HELPER ---
const InstancedTrees = ({ template, positions, scaleMultiplier = 1 }: { template: any, positions: number[][], scaleMultiplier?: number }) => {
    const meshRef = useRef<THREE.InstancedMesh>(null);
    
    useLayoutEffect(() => {
        if (!meshRef.current || !template || positions.length === 0) return;

        const dummy = new THREE.Object3D();

        for (let i = 0; i < positions.length; i++) {
            const [x, y, z] = positions[i];
            
            dummy.position.set(x, y, z);
            
            // Randomize Rotation (Y-axis)
            dummy.rotation.y = Math.random() * Math.PI * 2;
            
            // Randomize Scale (0.8x to 1.3x)
            const s = (0.8 + Math.random() * 0.5) * scaleMultiplier;
            dummy.scale.set(s, s, s);

            dummy.updateMatrix();
            meshRef.current.setMatrixAt(i, dummy.matrix);
        }

        meshRef.current.instanceMatrix.needsUpdate = true;
    }, [template, positions, scaleMultiplier]);

    if (!template) return null;

    return (
        <instancedMesh 
            ref={meshRef} 
            args={[template.geometry, template.material, positions.length]} 
            // SHADOWS REMOVED FOR OPTIMIZATION
        />
    );
};

export function TerrainModel({ isMobile = false }: { isMobile?: boolean }) {
  const { gl } = useThree();

  // Configure loader with KTX2 support using CDN transcoder
  const { nodes, scene } = useGLTF('./assets/map_done2.glb', true, undefined, (loader) => {
      const ktx2Loader = new KTX2Loader();
      ktx2Loader.setTranscoderPath('/basis/');
      ktx2Loader.detectSupport(gl);
      loader.setKTX2Loader(ktx2Loader);
  }) as any;

  useLayoutEffect(() => {
    if (scene) {
      scene.traverse((child: any) => {
        if (child.isMesh) {
           // SHADOWS REMOVED FOR OPTIMIZATION
           // child.castShadow = true;
           // child.receiveShadow = true;

           // Hide original trees so we can use our optimized instanced version
           if (child.name.startsWith('Tree')) {
               child.visible = false;
           }
        }
      });
    }
  }, [scene]);

  // OPTIMIZATION: Reduce tree count on mobile (render every 2nd or 3rd tree)
  const activeTreePositions = useMemo(() => {
     if (!isMobile) return treePositions;
     // Take only 40% of trees on mobile to reduce vertex count
     return treePositions.filter((_, i) => i % 2.5 === 0);
  }, [isMobile]);

  return (
    <group dispose={null}>
      
      {/* Render the full original scene (Tiles, Mountain, etc.) to preserve hierarchy and positions */}
      <primitive object={scene} />

      {/* Render Instanced Trees using external coordinates */}
      {nodes.Tree && (
        <InstancedTrees 
            template={nodes.Tree} 
            positions={activeTreePositions} 
            scaleMultiplier={1.5} 
        />
      )}
      
    </group>
  );
}

useGLTF.preload('./assets/map_done2.glb');